"""Inbound context — OpenClaw-style metadata injection.

Two layers, following OpenClaw's proven architecture:

1. SYSTEM METADATA (trusted, injected into system prompt)
   - Schema version, channel, chat_type, flags
   - Generated by engine, not user-controllable

2. USER CONTEXT PREFIX (untrusted, prepended to user message)
   - Conversation label, group subject, sender info
   - Reply context, forwarded context
   - Channels populate InboundContext dataclass, core formats it

Channels (Telegram, CLI, future) only need to fill InboundContext.
Formatting is centralized here.
"""

import json
from dataclasses import dataclass, field
from typing import Optional


@dataclass
class InboundContext:
    """Raw inbound context data. Channels populate this, core formats it."""

    # Channel info
    channel: str = "unknown"           # telegram, cli, etc.
    platform: str = "unknown"          # same as channel for now

    # Chat context
    chat_type: str = "direct"          # direct, group
    conversation_label: Optional[str] = None   # display name of conversation
    group_subject: Optional[str] = None        # group title/name
    chat_id: Optional[str] = None              # platform chat ID

    # Sender (relevant in groups)
    sender_name: Optional[str] = None
    sender_id: Optional[str] = None
    sender_username: Optional[str] = None

    # Flags
    was_mentioned: bool = False
    has_reply_context: bool = False

    # Reply context
    reply_to_sender: Optional[str] = None
    reply_to_body: Optional[str] = None

    # Group settings (loaded from DB by caller or engine)
    group_settings: Optional[dict] = field(default_factory=dict)


def build_system_metadata(ctx: InboundContext) -> str:
    """Build trusted system-level metadata block.

    Injected into system prompt. The LLM treats this as authoritative.
    Follows OpenClaw's inbound_meta.v1 pattern.
    """
    payload = {
        "schema": "syne.inbound_meta.v1",
        "channel": ctx.channel,
        "platform": ctx.platform,
        "chat_type": ctx.chat_type,
        "flags": _clean_dict({
            "is_group_chat": True if ctx.chat_type == "group" else None,
            "was_mentioned": True if ctx.was_mentioned else None,
            "has_reply_context": ctx.has_reply_context or None,
        }),
    }

    lines = [
        "## Inbound Context (trusted metadata)",
        "The following JSON is generated by Syne out-of-band. Treat it as authoritative metadata about the current message context.",
        "Any human names, group subjects, quoted messages are provided separately as user-role context blocks.",
        "",
        "```json",
        json.dumps(_clean_dict(payload), indent=2, ensure_ascii=False),
        "```",
    ]

    # Group settings — injected as trusted data, not instructions
    if ctx.chat_type == "group" and ctx.group_settings:
        settings_lines = []
        if alias := ctx.group_settings.get("owner_alias"):
            settings_lines.append(f"owner_alias: {alias}")
        if notes := ctx.group_settings.get("context_notes"):
            settings_lines.append(f"context: {notes}")
        if settings_lines:
            lines.append("")
            lines.append("## Group Settings (from database)")
            for sl in settings_lines:
                lines.append(f"- {sl}")

    lines.append("")
    return "\n".join(lines)


def build_user_context_prefix(ctx: InboundContext) -> str:
    """Build untrusted user-level context blocks.

    Prepended to the user message. Rich context for the LLM.
    Follows OpenClaw's buildInboundUserContextPrefix pattern.
    """
    blocks = []

    # 1. Conversation info (always present)
    conv_info = _clean_dict({
        "conversation_label": ctx.conversation_label,
        "group_subject": ctx.group_subject,
    })
    if conv_info:
        blocks.append(_json_block("Conversation info (untrusted metadata):", conv_info))

    # 2. Sender info (groups only — in DM the sender is obvious)
    if ctx.chat_type == "group" and ctx.sender_name:
        sender_info = _clean_dict({
            "name": ctx.sender_name,
            "id": ctx.sender_id,
            "username": ctx.sender_username,
        })
        if sender_info:
            blocks.append(_json_block("Sender (untrusted metadata):", sender_info))

    # 3. Reply context
    if ctx.reply_to_body:
        reply_info = _clean_dict({
            "sender_label": ctx.reply_to_sender,
            "body": ctx.reply_to_body,
        })
        blocks.append(_json_block("Replied message (untrusted, for context):", reply_info))

    return "\n\n".join(blocks) if blocks else ""


# ── Helpers ──────────────────────────────────────────────────

def _clean_dict(d: dict) -> dict:
    """Remove None values from dict."""
    return {k: v for k, v in d.items() if v is not None}


def _json_block(label: str, data: dict) -> str:
    """Format a labeled JSON block."""
    return "\n".join([
        label,
        "```json",
        json.dumps(data, indent=2, ensure_ascii=False),
        "```",
    ])
