"""Inbound context — OpenClaw-style metadata injection.

Two layers, following OpenClaw's proven architecture:

1. SYSTEM METADATA (trusted, injected into system prompt)
   - Schema version, channel, chat_type, flags
   - Generated by engine, not user-controllable

2. USER CONTEXT PREFIX (untrusted, prepended to user message)
   - Conversation label, group subject, sender info
   - Reply context, forwarded context
   - Channels populate InboundContext dataclass, core formats it

Channels (Telegram, CLI, future) only need to fill InboundContext.
Formatting is centralized here.

This is the SINGLE SOURCE OF TRUTH for per-message context.
No other module should query group settings, check is_group, or build
context blocks independently. If it's per-message metadata, it goes here.
"""

import json
import logging
from dataclasses import dataclass, field
from typing import Optional

logger = logging.getLogger("syne.inbound")


@dataclass
class InboundContext:
    """Raw inbound context data. Channels populate this, core formats it.

    This dataclass is the canonical representation of a single inbound message's
    context. Channels (Telegram, CLI) fill it at the edge; the engine uses it
    throughout without querying DB or platform APIs.
    """

    # ── Channel info ──────────────────────────────────────────
    channel: str = "unknown"           # telegram, cli, etc.
    platform: str = "unknown"          # same as channel for now

    # ── Chat context ──────────────────────────────────────────
    chat_type: str = "direct"          # direct, group
    conversation_label: Optional[str] = None   # display name of conversation
    group_subject: Optional[str] = None        # group title/name
    chat_id: Optional[str] = None              # platform chat ID

    # ── Sender (relevant in groups) ───────────────────────────
    sender_name: Optional[str] = None
    sender_id: Optional[str] = None
    sender_username: Optional[str] = None

    # ── Flags ─────────────────────────────────────────────────
    was_mentioned: bool = False
    has_reply_context: bool = False

    # ── Reply context ─────────────────────────────────────────
    reply_to_sender: Optional[str] = None
    reply_to_body: Optional[str] = None

    # ── Group settings (loaded from DB by channel at creation time) ──
    group_settings: Optional[dict] = field(default_factory=dict)

    # ── Derived convenience properties ────────────────────────

    @property
    def is_group(self) -> bool:
        return self.chat_type == "group"


async def load_group_settings(ctx: InboundContext) -> None:
    """Load group settings from DB into the InboundContext.

    Call this in the channel layer after creating InboundContext,
    before passing it downstream. This keeps all DB access at the edge.
    """
    if not ctx.is_group or not ctx.chat_id:
        return

    try:
        from ..db.connection import get_connection
        async with get_connection() as conn:
            row = await conn.fetchrow(
                "SELECT settings FROM groups WHERE platform = $1 AND platform_group_id = $2",
                ctx.platform, ctx.chat_id,
            )
        if row and row["settings"]:
            settings = json.loads(row["settings"]) if isinstance(row["settings"], str) else row["settings"]
            ctx.group_settings = settings
    except Exception as e:
        logger.warning(f"Failed to load group settings for {ctx.chat_id}: {e}")


def build_system_metadata(ctx: InboundContext) -> str:
    """Build trusted system-level metadata block.

    Injected into system prompt. The LLM treats this as authoritative.
    Follows OpenClaw's inbound_meta.v1 pattern.
    """
    payload = {
        "schema": "syne.inbound_meta.v1",
        "channel": ctx.channel,
        "platform": ctx.platform,
        "chat_type": ctx.chat_type,
        "flags": _clean_dict({
            "is_group_chat": True if ctx.is_group else None,
            "was_mentioned": True if ctx.was_mentioned else None,
            "has_reply_context": ctx.has_reply_context or None,
        }),
    }

    lines = [
        "## Inbound Context (trusted metadata)",
        "The following JSON is generated by Syne out-of-band. Treat it as authoritative metadata about the current message context.",
        "Any human names, group subjects, quoted messages are provided separately as user-role context blocks.",
        "",
        "```json",
        json.dumps(_clean_dict(payload), indent=2, ensure_ascii=False),
        "```",
    ]

    # Group settings — injected as trusted data, not instructions
    if ctx.is_group and ctx.group_settings:
        settings_lines = []
        if alias := ctx.group_settings.get("owner_alias"):
            settings_lines.append(f"owner_alias: {alias}")
        if notes := ctx.group_settings.get("context_notes"):
            settings_lines.append(f"context: {notes}")
        if settings_lines:
            lines.append("")
            lines.append("## Group Settings (from database)")
            for sl in settings_lines:
                lines.append(f"- {sl}")

    lines.append("")
    return "\n".join(lines)


def build_user_context_prefix(ctx: InboundContext) -> str:
    """Build untrusted user-level context blocks.

    Prepended to the user message. Rich context for the LLM.
    Follows OpenClaw's buildInboundUserContextPrefix pattern.
    """
    blocks = []

    # 1. Conversation info (always present)
    conv_info = _clean_dict({
        "conversation_label": ctx.conversation_label,
        "group_subject": ctx.group_subject,
    })
    if conv_info:
        blocks.append(_json_block("Conversation info (untrusted metadata):", conv_info))

    # 2. Sender info (groups only — in DM the sender is obvious)
    if ctx.is_group and ctx.sender_name:
        sender_info = _clean_dict({
            "name": ctx.sender_name,
            "id": ctx.sender_id,
            "username": ctx.sender_username,
        })
        if sender_info:
            blocks.append(_json_block("Sender (untrusted metadata):", sender_info))

    # 3. Reply context
    if ctx.reply_to_body:
        reply_info = _clean_dict({
            "sender_label": ctx.reply_to_sender,
            "body": ctx.reply_to_body,
        })
        blocks.append(_json_block("Replied message (untrusted, for context):", reply_info))

    return "\n\n".join(blocks) if blocks else ""


# ── Helpers ──────────────────────────────────────────────────

def _clean_dict(d: dict) -> dict:
    """Remove None values from dict."""
    return {k: v for k, v in d.items() if v is not None}


def _json_block(label: str, data: dict) -> str:
    """Format a labeled JSON block."""
    return "\n".join([
        label,
        "```json",
        json.dumps(data, indent=2, ensure_ascii=False),
        "```",
    ])
